# -*- coding: utf-8 -*-
"""Trabalho Final Estrutura de Dados 27/06

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RjePgVibs7LBT-WE0RyRuG6D7l8UAWIv
"""

def initial_graph() :

    return {
         "criciuma" : {"nova veneza": 4, "sideropolis": 8},
         "nova veneza" : {"criciuma": 4, "lauro muller": 8, "sideropolis": 11},
         "sideropolis" : {"criciuma": 8, "urussanga": 1, "nova veneza": 11, "treviso":7},
         "urussanga" : {"turvo": 2, "treviso": 6, "sideropolis": 1},
         "turvo" : {"urussanga": 2, "içara": 14, "ararangua": 10, "lauro muller": 4},
         "ararangua" : {"turvo": 10, "içara": 9},
         "içara" : {"ararangua": 9, "turvo": 14, "lauro muller": 7},
         "lauro muller" : {"nova veneza": 8, "içara": 7, "treviso": 2},
         "treviso": {"lauro muller": 2, "urussanga": 6, "sideropolis": 7},
}

print(initial_graph())

initial = 'criciuma'
path = {}
adj_node = {}
queue = []
graph = initial_graph()
for node in graph:
    path[node] = float("inf")
    adj_node[node] = None
    queue.append(node)

path[initial] = 0
while queue:
    # encontre a distância mínima que não foi marcada como atual
    key_min = queue[0]
    min_val = path[key_min]
    for n in range(1, len(queue)):
        if path[queue[n]] < min_val:
            key_min = queue[n]
            min_val = path[key_min]
    cur = key_min
    queue.remove(cur)
    print(cur)

    for i in graph[cur]:
        alternate = graph[cur][i] + path[cur]
        if path[i] > alternate:
            path[i] = alternate
            adj_node[i] = cur

import sys

# Função do algoritmo de Dijkstra
def calcular_dijkstra(grafo, origem):

    # Inicialização das distâncias com infinito, exceto a origem que é zero
    distancias = {v: sys.maxsize for v in grafo}
    distancias[origem] = 0

    # Conjunto de vértices visitados
    visitados = set()

    while visitados != set(distancias):
        # Encontra o vértice não visitado com menor distância atual
        vertice_atual = None
        menor_distancia = sys.maxsize
        for v in grafo:
            if v not in visitados and distancias[v] < menor_distancia:
                vertice_atual = v
                menor_distancia = distancias[v]

        # Marca o vértice atual como visitado
        visitados.add(vertice_atual)

        # Atualiza as distâncias dos vértices vizinhos
        for vizinho, peso in grafo[vertice_atual].items():
            if distancias[vertice_atual] + peso < distancias[vizinho]:
                distancias[vizinho] = distancias[vertice_atual] + peso

    # Retorna as distâncias mais curtas a partir da origem
    return distancias

# Definindo o grafo com as conexões e custos
grafo = {
    "criciuma" : {"nova veneza": 4, "sideropolis": 8},
         "nova veneza" : {"criciuma": 4, "lauro muller": 8, "sideropolis": 11},
         "sideropolis" : {"criciuma": 8, "urussanga": 1, "nova veneza": 11, "treviso":7},
         "urussanga" : {"turvo": 2, "treviso": 6, "sideropolis": 1},
         "turvo" : {"urussanga": 2, "içara": 14, "ararangua": 10, "lauro muller": 4},
         "ararangua" : {"turvo": 10, "içara": 9},
         "içara" : {"ararangua": 9, "turvo": 14, "lauro muller": 7},
         "lauro muller" : {"nova veneza": 8, "içara": 7, "treviso": 2},
         "treviso": {"lauro muller": 2, "urussanga": 6, "sideropolis": 7},
}

# Ponto de partida
origem = 'criciuma'

# Chamando o algoritmo de Dijkstra para encontrar os caminhos mais curtos a partir de A
caminhos_mais_curto = calcular_dijkstra(grafo, origem)

while True:
    opcao = 0
    print("-----------------------------------------------------")
    print("1 - Listar todos os caminhos")
    print("2 - Escolher caminho traçado")
    opcao = int(input("Escolha uma opção acima: "))
    print("-----------------------------------------------------")

    if opcao == 1:
    # Exibindo os caminhos mais curtos
        for destino, distancia in caminhos_mais_curto.items():
            print(f"Caminho mais curto de {origem} para {destino}: {distancia}")

    elif opcao == 2:
        dist = input("A origem é Criciuma, para onde deseja viajar?: ").lower()
        if dist in caminhos_mais_curto:
            print(f"Caminho mais curto de {origem} para {dist}: {caminhos_mais_curto[dist]}")
        else:
            print("Destino inválido.")
    else:
        print("Opção inválida. Escolha 1 ou 2.")